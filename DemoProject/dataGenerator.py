import sys
import numpy as np
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
import pandas as pd

# generate data files
num_of_files = 30#00000
f = 0

days_of_data = 2
days_of_data_count = 0

# patient ID
num_of_patients_count = 0
num_of_patients = 1

# wearable device ID
num_of_devices = 10000
num_of_devices_count = 0

# heart rate
HR_Max = 120
HR_Min = 60

# ambient temp
ambientTemp_Max = 45
ambientTemp_Min = -40

# skin temp
skinTemp_Max = 35
skinTemp_Min = 15

# venous oxygen saturation (SvO2)
SvO2_Max = 100
SvO2_Min = 0

# oxygen uptake (VO2) 
VO2_Max = 100
VO2_Min = 0

# GPS location
GPS_Max = 100
GPS_Min = 0

# ACC
ACC_Max = 2
ACC_Min = -2

# Gyro
Gyro_Max = 250
Gyro_Min = -250

# critical priority from thresholds preset:computation

# medicine when consumed:user input

# alert:device trigger/interrupt

def linearInterpolation():
    # https://mmas.github.io/interpolation-scipy
    x = np.linspace(0,4,12)
    y = np.cos(x**2/3+4)

    # smothing the above
    xn = np.linspace(0,4,100)
    y0 = np.cos(xn**2/3+4)

    # compute linear interpolation
    yn = np.interp(xn, x, y) # x axis scale, known sample point, y axis scale

    plt.plot(xn, y0, '--k', label = "True Values")
    plt.plot(x, y, 'ok', label="Known points")
    plt.plot(xn, yn, label = "interpolation values")
    plt.legend()
    plt.show()

# generate heart rate
def HeartRate_PerDay():
    '''
    x_sample_points max value in array has to be bigger then freq_sample_points_available max value in array
    '''
    x_sample_points = np.arange(0, (60*60*24)+60, 60) # one sample per minute. The +60 adds to the range for the interpolation to work
    # generates an array of size shape filled with random numbers between 0 and 1
    # size = (2, 5) generates 2d array with 2 rows and 5 columns
    freq_sample_points_available = np.random.random(size=x_sample_points.shape) * HR_Max + HR_Min
    
    # remove the decimal point generated by random. for this projects, an integer value is enough
    freq_sample_points_available = freq_sample_points_available.astype(int)
 
    # x axis scale = sample per second
    full_x_axis = np.arange(0, 60*60*24, 1) # one sample per second

    # generate quadratic wave from the given sample points. 
    interpolation = interp1d(x_sample_points, freq_sample_points_available, kind='quadratic')
    # stretch / fill in points for the whole scale
    heartRate = interpolation(full_x_axis)


    # plt.plot(full_x_axis, heartRate, label="freq(x)")
    # plt.legend()
    # plt.show()

    return heartRate.astype(int)

# generate Accelerometer
def Accelerometer_PerDay():
    return np.random.randint(size=(3,(60*60*24)), low = ACC_Min, high = ACC_Max)

# generate Gyro
def Gyro_PerDay():
    return np.random.randint(size=(3,(60*60*24)), low = Gyro_Min, high = Gyro_Max)

# generate ambient temp
def AmbientTemp_PerDay():
    return np.random.randint(size=(60*60*24), low = ambientTemp_Min, high = ambientTemp_Max)

# generate skin temp
def SkinTemp_PerDay():
    return np.random.randint(size=(60*60*24), low = skinTemp_Min, high = skinTemp_Max)

# generate venous oxygen saturation (SvO2)
def OxySat_PerDay():
    return np.random.randint(size=(60*60*24), low = SvO2_Min, high = SvO2_Max)

# generate oxygen uptake (VO2)
def OxyVO_PerDay():
    return np.random.randint(size=(60*60*24), low = VO2_Min, high = VO2_Max)
    
# generate GPS location
def GPS_PerDay():
    return np.random.randint(size=(2,(60*60*24)), low = GPS_Min, high = GPS_Max)

# generate dataframe
def groupData(patNum, dayNum, devID):
    hr = pd.Series(HeartRate_PerDay(), name="heartRate")
    
    acc = Accelerometer_PerDay()
    acc_x = pd.Series(acc[0], name="Acc_x")
    acc_y = pd.Series(acc[1], name="Acc_y")
    acc_z = pd.Series(acc[2], name="Acc_z")

    gyr = Gyro_PerDay()
    gyr_x = pd.Series(gyr[0], name="Gyr_x")
    gyr_y = pd.Series(gyr[1], name="Gyr_y")
    gyr_z = pd.Series(gyr[2], name="Gyr_z")

    amb = pd.Series(AmbientTemp_PerDay(), name="AmbT")

    sk = pd.Series(SkinTemp_PerDay(), name="SknT")

    sat = pd.Series(OxySat_PerDay(), name="OxyS")

    vo = pd.Series(OxyVO_PerDay(), name="OxyV")

    gps = GPS_PerDay()
    gps_lat = pd.Series(gps[0], name="Lat")
    gps_lon = pd.Series(gps[1], name="Long")

    time = pd.Series(np.arange(0, (60*60*24), 1), name="TimeStamp")


    # combine series
    df = pd.concat([time, hr, acc_x, acc_y, acc_z, gyr_x, gyr_y, gyr_z, amb, sk, sat, vo, gps_lat, gps_lon], axis=1)
    df['DeviceID'] = devID
    df.set_index('TimeStamp', inplace=True)
    df.to_csv(f".\Spark_Stuff\DemoProject\DataSets\Pat_{patNum}_Day_{dayNum}.txt")



while 1:
    if num_of_devices_count < num_of_devices: # loop until all devices are used
        if days_of_data_count < days_of_data: # loop days of patient
            # generate data
            groupData(num_of_patients_count, days_of_data_count, num_of_devices_count)
            days_of_data_count += 1
            

            if num_of_patients_count == num_of_patients: # loop until max file count is reached
                sys.exit()
        else:
            days_of_data_count = 0
            num_of_devices_count += 1 # new device new patient
            num_of_patients_count += 1 # each batch of days for every patient
    else:
        num_of_devices_count = 0 # restart using devices

    

